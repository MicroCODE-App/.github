# ðŸ˜Ž feature/0003--use-mongodb-ids (app-template)

| Issue # | PR #    | Requested by | Implemented by  | Date       | Release # |
| ------- | ------- | ------------ | --------------- | ---------- | --------- |
| `#0003` | `#pppp` | MongoDB      | Timothy McGuire | 2025-11-27 | `a0.0.0`  |

- **Source Branch:** `main`
- **Working Branch:** `feature/0003--use-mongodb-ids`
- **Target Branch:** `develop`
- **Tag:** `a0.0.0`

## Request

Summary description of the requested feature or change. Include links to product requirements, customer tickets, or GitHub issues as applicable.

Migrate ID generation from `uuidv4()` to `utility.unique_id('prefix')` pattern, standardize timestamp fields to `created_at`/`updated_at`, and add `type` and `state` fields across all models. Keep MongoDB `_id` invisible (handled automatically) while using `id` as the application-level primary key.

## Current Behavior (AS-IS)

Describe in detail the current behavior, including screenshots, logs, or relevant references.

Kyle's original implementation uses custom random IDs for all entities.
This requires additional logic to manage ID generation and uniqueness.

- **Current UI, Workflow or Code:**
<p align="left"><img src="./.images/issue-0003-before.png" width="720" title="Current behavior" style="border: 0.5px solid lightgray;"></p>

## Requested Behavior (TO-BE)

Describe in detail the desired behavior. Include acceptance criteria, UX/UI mocks, API changes, and any non-functional requirements.

**Implemented Approach:**

1. **ID Generation**: Use `utility.unique_id('prefix')` with entity-specific 4-character prefixes (e.g., `'acct'`, `'user'`, `'evnt'`) instead of `uuidv4()`. This provides human-readable entity prefixes while maintaining uniqueness.

2. **MongoDB `_id`**: Keep MongoDB's `_id` field invisible and automatically managed by MongoDB. The application uses `id` as the primary key field.

3. **Helper Function**: Use `mongo.createOrdered(KEY_PREFIX, Model, data)` helper which automatically:

   - Generates `id` using `utility.unique_id(KEY_PREFIX)`
   - Sets `created_at` to current date
   - Sets `updated_at` to null
   - Sets `rev` to 0
   - Preserves schema field ordering

4. **Timestamps**: Standardize to `created_at`/`updated_at` pattern across all entities, with exceptions for domain-specific semantics (e.g., `issued_at`/`expires_at` for tokens, `period_start`/`period_end` for usage).

5. **Type & State Fields**: Add `type` and `state` enum fields to all models for entity classification and lifecycle management.

This approach simplifies ID generation, provides consistent timestamp handling, and maintains compatibility with MongoDB while using human-readable entity prefixes.

## ID Design Policy (Global)

### 0. Table/Collection Names

- Use **singular** names for all tables/collections.
- SQL tables use the same singular entity name as the MongoDB collection (no `tbl_` prefix), e.g. `user`, `account`.
- MongoDB collections are named without prefixes (e.g. `user`, `account`).

### 1. Primary Keys

- **Canonical name**: Every persisted record has exactly one application-level primary key named `id`.
- **MongoDB `_id`**: Kept invisible and automatically managed by MongoDB. Not used as application primary key.
- **Table/collection naming**:
  - Tables/collections that hold individual entities use **singular** names.
  - Example: a collection of all users is `user`; each document is one `user` entity.
- **Type by store**:
  - MongoDB: `id` is a String generated by `utility.unique_id('prefix')` with format `prefix_timestamp+random`. MongoDB's `_id` is automatically managed and kept invisible.
  - SQL (or any other DB): `id` is the primary key column name, generated using `utility.unique_id('prefix')` to preserve the same semantics (unique, human-readable prefix).
- **Creation**:
  - For MongoDB: Generated by `mongo.createOrdered(KEY_PREFIX, Model, data)` helper which calls `utility.unique_id(KEY_PREFIX)`.
  - For SQL: Explicit `utility.unique_id('prefix')` calls in create functions.

### 2. Foreign Keys and Relationships

- **Foreign key naming (singular)**:
  - Any reference to another entity uses: `{entity_name}_id`, where `{entity_name}` is singular.
  - Example:
    - Entity collection: `user`
    - Primary key: `id`
    - Foreign key in another collection: `user_id`
- **Join/association tables**:
  - Use one column per referenced entity, each following the same pattern.
  - Example: a `user_role` collection might have `user_id` and `role_id`.
  - If we encounter ambiguous cases (e.g. `user_roles_id`), we will explicitly decide and document them, defaulting to the simple singular rule above.
- **Lists of IDs**:
  - For arrays of references, use `{entity_name}_ids` (plural suffix).
  - Example: `role_ids` as an array of `id` values referencing the `role` collection.

### 3. Representation Across Layers

- **Backend (Node/JS)**:
  - `id` is a String generated by `utility.unique_id('prefix')` with format `prefix_timestamp+random`.
  - MongoDB's `_id` is kept invisible and automatically managed.
- **APIs / JSON / Frontends**:
  - `id` is serialized as a string with entity prefix (e.g., `acct_...`, `user_...`).
  - Foreign keys (`{entity}_id`, `{entity}_ids`) follow the same string format.
- **Public identifier pattern (external IDs)**:
  - External/public identifiers (API responses, URLs, webhooks, partner integrations) may use the `id` field directly since it already contains human-readable prefixes.
  - When additional external identifiers are needed, define a dedicated public ID field (e.g. `user_ref`, `acct_ref`, or a prefixed code).

### 4. Hard Rules and Prohibitions

- **Primary key naming**:
  - Use `id` as the application-level primary key field name for every entity.
  - MongoDB's `_id` is kept invisible and automatically managed - do not reference it in application code.
- **ID generation**:
  - Use `utility.unique_id('prefix')` with entity-specific 4-character prefixes for all ID generation.
  - Do not use `uuidv4()`, numeric auto-increment, or other schemes as the primary key.
  - Use `mongo.createOrdered(KEY_PREFIX, Model, data)` helper for MongoDB models.
  - Use explicit `utility.unique_id('prefix')` calls for SQL models.
- **No TypeScript**:
  - This codebase remains JavaScript-only. Do not introduce TypeScript or TS tooling.

### 5. Exposure and Integration

- **Internal vs external IDs**:
  - `id` and all `{entity}_id` / `{entity}_ids` fields use human-readable prefixes and may be exposed in APIs.
  - MongoDB's `_id` is kept invisible and should never be exposed in application code or APIs.
- **Logging and observability**:
  - Internal logs and metrics may include `id` values (with prefixes) for debugging.
  - MongoDB's `_id` values should not appear in application logs or APIs.

### 6. Cross-App Consistency

- **Applies to all apps**:
  - This policy is global across `server`, `admin`, `client`, `portal`, `app`, and any new services or workers.
- **Future enforcement**:
  - All new schemas, migrations, routes, and models must adhere to this policy.
  - Any exception (e.g. due to a legacy or third-party constraint) must be explicitly documented at the point of use.

### 7. External ID Prefix Pattern (Draft)

- **Goal**: Derive short, human-recognizable prefixes for external IDs from the entity/table name.
- **Initial proposal**:
  - Start with the singular entity name (e.g. `user`, `organization`, `invoice`).
  - Take consonants in order until you have 3 characters (padding with vowels if needed).
  - Examples (hypothetical):
    - `user` â†’ `usr_XXXXXXXX`
    - `organization` â†’ `org_XXXXXXXX`
    - `invoice` â†’ `inv_XXXXXXXX`
- **Status**:

  - This is an initial idea and not yet final.
  - Finalization of the external ID prefix scheme will be done before any public APIs, webhooks, or partner integrations are declared stable.

## Reason for Change

MongoDB ObjectIDs are optimized for performance and storage efficiency.
Using them will reduce complexity in our codebase and improve maintainability.

## Implementation Plan

This change will involve updating the data models, database access layers,
and any related business logic to use MongoDB ObjectIDs. I've already down this once to
Kyle's original implementation, in the original LADDERS code, so this will be a reversion to that approach.

- **Repositories / Modules affected:** `server`, `admin`, `client`, `app`, `portal`, `template`, `bin`
- **Dependencies / External systems:** MongoDB, SQL (optional), third-party providers (e.g. Stripe, Mailgun)
- **Database Changes:**
  - Update schemas to use `id` (generated by `utility.unique_id('prefix')`) as primary key
  - Keep MongoDB `_id` invisible and automatically managed
  - Standardize timestamps to `created_at`/`updated_at` (with domain-specific exceptions)
  - Add `type` and `state` enum fields to all models
  - Continue using `{entity}_id` foreign keys
- **Testing Plan:** Expanded unit and integration tests enforcing `id` usage with proper prefixes, timestamp standardization, and type/state fields; generator/template tests.
- **Risks & Mitigations:** Template-only change (no production DBs yet) minimizes risk. Strong test coverage to enforce rules before release.
- **Rollout Plan:** Apply changes in template repos (`server`, `admin`, etc.), ensure all tests pass, then use updated template for new apps.
- **Back-out Plan:** Revert template branches to pre-feature state if design or tests reveal issues.

## Design

### A. Global ID Semantics

- Internal DB IDs:
  - Primary key for all entities: `id` (String generated by `utility.unique_id('prefix')` with format `prefix_timestamp+random`).
  - MongoDB `_id`: Kept invisible and automatically managed by MongoDB.
  - Foreign keys: `{entity}_id` (singular entity name), arrays as `{entity}_ids`.
  - Entity-specific 4-character prefixes: `acct`, `user`, `evnt`, `fdbk`, `invt`, `apik`, `log_`, `logn`, `notf`, `psht`, `tokn`, `used`, `mail`.
- External/public IDs (our own):
  - `{entity}_ref` may be generated when an entity is first published externally (future enhancement).
  - The `id` field with entity prefixes may be used directly in APIs.
- External system IDs:
  - `{provider}_{entity}_ref`, e.g. `stripe_customer_ref`, `stripe_subscription_ref`, `mailgun_message_ref`.
  - Never end with `_id`; `_id` is reserved for MongoDB's internal field (kept invisible).

### B. ID Generation: Helper Function Approach

**Implemented Approach:**

- **MongoDB Models**: Use `mongo.createOrdered(KEY_PREFIX, Model, data)` helper function which:

  - Automatically generates `id` using `utility.unique_id(KEY_PREFIX)`
  - Sets `created_at` to current date
  - Sets `updated_at` to null
  - Sets `rev` to 0
  - Preserves schema field ordering
  - Resolves schema defaults

- **MongoDB `_id`**: Omit from schema definitions - let MongoDB create it automatically. Keep it invisible in application code.

- **SQL Models**: Use explicit `utility.unique_id('prefix')` calls in create functions (no schema defaults).

- **Exception**: `usage.mongo.js` uses schema default `default: () => utility.unique_id('used')` due to custom save hooks.

**Schema Definition Pattern:**

```javascript
const KEY_PREFIX = 'acct';
const mongo = require('../helper/mongo');

const schema = new mongoose.Schema({
    id: {
        type: String,
        required: true,
        unique: true
    },
    // ... other fields
    created_at: Date,
    updated_at: Date,
    type: { type: String, enum: [...], default: '...' },
    state: { type: String, enum: [...], default: '...' }
});

// Create function uses helper
exports.create = async function (data) {
    return await mongo.createOrdered(KEY_PREFIX, Model, data);
};
```

### C. Entity Prefix Mapping

#### C.1 Prefix Assignment

Each entity uses a 4-character prefix defined as a constant (`KEY_PREFIX`) in the model file:

**Database Entities:**

- `account` â†’ `'acct'`
- `user` â†’ `'user'`
- `event` â†’ `'evnt'`
- `feedback` â†’ `'fdbk'`
- `invite` â†’ `'invt'`
- `key` (API key) â†’ `'apik'`
- `log` â†’ `'log_'`
- `login` â†’ `'logn'`
- `notification` â†’ `'notf'`
- `pushtoken` â†’ `'psht'`
- `token` â†’ `'tokn'`
- `usage` â†’ `'used'`
- `email` â†’ `'mail'`

**Non-Database Entities:**

- `job` (queue) â†’ `'jobs'` (Redis/Bull)
- `file` (upload) â†’ `'file'` (S3/File System)

#### C.2 ID Format

- Format: `prefix_timestamp+random`
- Example: `acct_20251202143052abc123`, `user_20251202143052def456`
- Generated by: `utility.unique_id(KEY_PREFIX)`

#### C.3 External References (Future)

- The `id` field with entity prefixes may be used directly in APIs and external integrations.
- Future enhancement: `{entity}_ref` fields may be added for additional external reference needs.

### D. Server Design & Refactor Plan

- **Mongo Helper Module** (`server/helper/mongo.js`):

  - `createOrdered(idKey, Model, data)` â€“ creates documents with automatic ID generation, timestamps, and revision numbers.
    - Generates `id` using `utility.unique_id(idKey)`
    - Sets `created_at` to current date
    - Sets `updated_at` to null
    - Sets `rev` to 0
    - Preserves schema field ordering
    - Resolves schema defaults

- **Utility Module** (`server/helper/utility.js`):

  - `unique_id(prefix)` â€“ generates ID with format `prefix_timestamp+random`.

- **Routes** (`server/api/*.route.js`):

  - Use singular entity names, e.g. `/api/user`, `/api/account`.
  - Use `:id` and `{entity}_id` as route params (e.g., `/api/user/:id`).
  - Validate incoming `id` values match expected prefix format.

- **Controllers** (`server/controller/**/*.js`):

  - Use `id` as the primary key field name.
  - Function names may use `Id` (e.g. `getUserById`), and parameters/fields use `id` / `{entity}_id`.
  - Responses include `id` and `{entity}_id`/`{entity}_ids`.

- **Models & Schemas** (`server/model/mongo/**`, `server/model/sql/**`, `server/migrations/**`):

  - **MongoDB**:
    - Define `id: { type: String, required: true, unique: true }` as primary key.
    - Omit `_id` from schema (let MongoDB handle it automatically).
    - Use `{entity}_id` fields typed as `String` for references.
    - Use `mongo.createOrdered(KEY_PREFIX, Model, data)` in create functions.
    - Include `created_at`, `updated_at`, `type`, and `state` fields.
  - **SQL**:
    - Use `id VARCHAR(255)` as primary key (or appropriate length for prefix format).
    - Use `{entity}_id VARCHAR(255)` as foreign keys referencing corresponding `id`.
    - Use explicit `utility.unique_id('prefix')` calls in create functions.

- **Timestamps**:

  - Standard `created_at`/`updated_at` for all entities.
  - Exceptions: `issued_at`/`expires_at` (tokens), `period_start`/`period_end` (usage), `active_at` (users).

- **Type & State Fields**:
  - Add `type` enum field to all models (entity-specific values).
  - Add `state` enum field to all models (common values: `onboarding`, `active`, `inactive`, `suspended`, `archived`).

### E. Admin / Console Design

- All admin/console code lives under `app-template/admin` (backend and frontend) and may have a `console/` frontend.
- **Backend**:
  - Mirrors server semantics: `id` and `{entity}_id` everywhere.
  - Uses the same `createOrdered()` helper and ID generation patterns when interacting with server and external systems.
- **Frontend**:
  - Entity lists and detail pages keyed by `id`.
  - Routes like `/user/:id` for admin-only views.
  - Diagnostic views (guarded by ADMIN role) show `id` (with prefixes), `{entity}_ref` (if implemented), and external `{provider}_{entity}_ref` values.

## Test Plan (Structure and Coverage)

### Server Tests

- **Structure**:
  - `server/test/unit/`
    - `helper/mongo.test.js` â€“ tests `createOrdered()` ID generation, timestamp setting, and revision initialization.
    - `helper/utility.test.js` â€“ tests `unique_id()` format and prefix handling.
    - `model/<entity>.model.test.js` â€“ asserts `id` presence and format (prefix match), `{entity}_id` correctness, `created_at`/`updated_at` timestamps, and `type`/`state` fields.
  - `server/test/integration/`
    - `api/user.api.test.js`, `api/account.api.test.js`, etc. â€“ CRUD tests using `/api/user/:id` and verifying response shapes include `id` with proper prefix.
    - Timestamp tests â€“ ensure `created_at` is set on creation and `updated_at` is set on updates.
  - Optional static tests:
    - `test/unit/static/id-naming.test.js` â€“ scans models/migrations to ensure `id` is present as primary key and uses `createOrdered()` helper or explicit `unique_id()` calls.

### Admin / Console Tests

- **Unit tests**:
  - Components use `_id` for keys and routing, not `id`.
  - Diagnostic components show `_id` and refs only when ADMIN role is active.
- **Integration / e2e tests**:
  - Admin flows create and edit entities via APIs that use `_id`/`{entity}_id`.
  - Diagnostic views are inaccessible to non-admin users and correctly display internal `_id` and external refs for admins.

### Template / Generator Tests

- **Generator tests** for `template/**` and `bin/**`:

  - Run scaffolding scripts to generate sample resources.
  - Assert generated code:
    - Uses `id` (generated by `utility.unique_id('prefix')`), `{entity}_id`, `{entity}_ids` for internal IDs.
    - Uses `mongo.createOrdered(KEY_PREFIX, Model, data)` for MongoDB models.
    - Uses explicit `utility.unique_id('prefix')` for SQL models.
    - Includes `created_at`, `updated_at`, `type`, and `state` fields.
    - Uses `:id` in routes (not `:_id`).
    - Optionally includes `{entity}_ref` fields for externally-visible entities (future enhancement).

## Proposed UI, Workflow or Code:

<p align="left"><img src="./.images/issue-0003-after.png" width="720" title="Requested behavior" style="border: 0.5px solid lightgray;"></p>

---

## PHASE 6: USER SETTINGS SYSTEM - DETAILED DESIGN

### Overview

This phase integrates a hierarchical user settings system from the ladders repository into the app-template. The settings system allows users to store and retrieve application preferences using a three-level hierarchical key structure: `subsystem.feature.setting`.

### Design Principles

Following the AI-RULES.md guidelines:

- **Separation of Concerns**: Settings logic in model layer, business logic in controller layer
- **Consistency**: Follow existing patterns (CRUD ordering, JSDoc headers, nested exports)
- **Security**: Validate all inputs, prevent mass assignment, use account_id scoping where applicable
- **Testability**: All functions must be testable with clear inputs/outputs

### Architecture

#### 1. Data Model

**Location**: `server/model/mongo/user.mongo.js`

**Schema Addition**:

```javascript
settings: {
    type: Object,
    required: false,  // Optional to support existing users during migration
    default: () => ({})  // Initialize as empty object
}
```

**Rationale**:

- `required: false` allows existing users without settings to continue working
- Default empty object prevents null checks throughout codebase
- MongoDB `Object` type allows flexible nested structure

#### 2. Model Functions

**Location**: `server/model/mongo/user.mongo.js` (Special Functions section)

**Function Signatures**:

```javascript
/**
 * @func settings.get
 * @memberof model.mongo.user
 * @desc Retrieve a specific setting value using hierarchical key path
 * @api public
 * @param {object} params Parameters object
 * @param {string} [params.id] User ID (required if email not provided)
 * @param {string} [params.email] User email (required if id not provided)
 * @param {string} params.key Hierarchical key path (format: "subsystem.feature.setting")
 * @returns {Promise<*|null>} Setting value, subsystem object, feature object, or null if not found
 */
exports.settings = {};
exports.settings.get = async function({ id, email, key }) { ... }

/**
 * @func settings.set
 * @memberof model.mongo.user
 * @desc Set a specific setting value using hierarchical key path
 * @api public
 * @param {object} params Parameters object
 * @param {string} [params.id] User ID (required if email not provided)
 * @param {string} [params.email] User email (required if id not provided)
 * @param {string} params.key Hierarchical key path (format: "subsystem.feature.setting")
 * @param {*} params.value Value to set (any type)
 * @returns {Promise<object>} Updated user document (without password)
 */
exports.settings.set = async function({ id, email, key, value }) { ... }

/**
 * @func settings.setAll
 * @memberof model.mongo.user
 * @desc Replace entire settings object for a user
 * @api public
 * @param {object} params Parameters object
 * @param {string} [params.id] User ID (required if email not provided)
 * @param {string} [params.email] User email (required if id not provided)
 * @param {object} params.settings Complete settings object to replace existing settings
 * @returns {Promise<object>} Updated user document (without password)
 */
exports.settings.setAll = async function({ id, email, settings }) { ... }
```

**Key Design Decisions**:

1. **Query Pattern**: Use `id` field (not `_id`) to match current implementation pattern
2. **Flexible Lookup**: Support both `id` and `email` for flexibility
3. **Hierarchical Keys**: Support 1-3 level keys:
   - `"subsystem"` â†’ returns entire subsystem object
   - `"subsystem.feature"` â†’ returns entire feature object
   - `"subsystem.feature.setting"` â†’ returns specific setting value
4. **MongoDB markModified**: Required for nested object updates
5. **Revision Tracking**: Increment `rev` and update `updated_at` on settings changes

#### 3. Controller Functions

**Location**: `server/controller/user.controller.js` (Special Functions section)

**Function Signatures**:

```javascript
/**
 * @func settings.get
 * @memberof controller.user
 * @desc Get a user setting value by hierarchical key. Returns setting value, subsystem, or feature object.
 * @api private
 * @param {object} req Express request object (requires authentication middleware)
 * @param {string} req.user User ID from authentication middleware
 * @param {string} req.account Account ID from authentication middleware
 * @param {object} req.query Query parameters
 * @param {string} req.query.key Hierarchical key path (required)
 * @param {object} res Express response object
 * @returns {Promise<void>} Sends setting value or null
 */
exports.settings = {};
exports.settings.get = async function(req, res) { ... }

/**
 * @func settings.set
 * @memberof controller.user
 * @desc Set a user setting value by hierarchical key
 * @api private
 * @param {object} req Express request object (requires authentication middleware)
 * @param {string} req.user User ID from authentication middleware
 * @param {string} req.account Account ID from authentication middleware
 * @param {object} req.body Request body
 * @param {string} req.body.key Hierarchical key path (required)
 * @param {*} req.body.value Value to set (required)
 * @param {object} res Express response object
 * @returns {Promise<void>} Sends success message
 */
exports.settings.set = async function(req, res) { ... }

/**
 * @func settings.setAll
 * @memberof controller.user
 * @desc Replace all user settings with new settings object
 * @api private
 * @param {object} req Express request object (requires authentication middleware)
 * @param {string} req.user User ID from authentication middleware
 * @param {string} req.account Account ID from authentication middleware
 * @param {object} req.body Request body
 * @param {object} req.body.settings Complete settings object (required)
 * @param {object} res Express response object
 * @returns {Promise<void>} Sends success message
 */
exports.settings.setAll = async function(req, res) { ... }
```

**Key Design Decisions**:

1. **Input Validation**: Use `utility.validate()` with Joi schemas for all inputs
2. **Permission Checks**: Users can only modify their own settings (enforced by `req.user`)
3. **Error Handling**: Use `utility.assert()` for validation errors
4. **Response Format**: Consistent with existing controller patterns (`{ message, data }`)

#### 4. API Routes

**Location**: `server/api/user.route.js`

**Route Definitions**:

```javascript
// Get setting
api.get(
  "/api/user/settings",
  auth.verify("user", "user.read"),
  use(userController.settings.get)
);

// Set single setting
api.put(
  "/api/user/settings",
  auth.verify("user", "user.update"),
  use(userController.settings.set)
);

// Replace all settings
api.put(
  "/api/user/settings/all",
  auth.verify("user", "user.update"),
  use(userController.settings.setAll)
);
```

**Key Design Decisions**:

1. **RESTful Design**: Use GET for retrieval, PUT for updates
2. **Authentication**: Require `user` permission level (all authenticated users)
3. **API Scopes**: Use `user.read` for GET, `user.update` for PUT operations
4. **Route Naming**: `/api/user/settings` for single operations, `/api/user/settings/all` for bulk

#### 5. Configuration

**Location**: `server/config/default.json`

**Configuration Addition**:

```json
{
  "settings": {
    "default": {}
  }
}
```

**Rationale**:

- Empty default object allows applications to define their own settings structure
- Can be extended per-application without template changes
- Provides initialization point for new users

**User Creation Update**:

**Location**: `server/model/mongo/user.mongo.js` - `exports.create`

**Change**:

```javascript
const config = require("config");
// ... in create function
const userData = {
  // ... existing fields
  settings: config.get("settings.default") || {},
  // ...
};
```

#### 6. API Specification

**Location**: `server/api/spec.yaml`

**Add to User schema**:

```yaml
User:
  type: object
  properties:
    # ... existing properties
    settings:
      type: object
      description: User settings object with hierarchical structure
      additionalProperties: true
```

**Add new endpoints**:

```yaml
paths:
  /user/settings:
    get:
      summary: Get user setting by key
      parameters:
        - name: key
          in: query
          required: true
          schema:
            type: string
      responses:
        200:
          description: Setting value retrieved
    put:
      summary: Set user setting by key
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [key, value]
              properties:
                key:
                  type: string
                value:
                  description: Any JSON-serializable value
      responses:
        200:
          description: Setting updated
  /user/settings/all:
    put:
      summary: Replace all user settings
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [settings]
              properties:
                settings:
                  type: object
                  additionalProperties: true
      responses:
        200:
          description: All settings updated
```

### Implementation Details

#### Model Function Implementation

**getSetting Logic**:

1. Validate that either `id` or `email` is provided
2. Build query: `{ id: id }` or `{ email: email }`
3. Find user document
4. If user exists and has settings:
   - Split key by `.` to get parts array
   - Navigate through settings object: `settings[parts[0]][parts[1]][parts[2]]`
   - Return appropriate level based on key depth
5. Return `null` if not found

**setSetting Logic**:

1. Validate that either `id` or `email` is provided, and `key` and `value` are provided
2. Build query: `{ id: id }` or `{ email: email }`
3. Find user document (use `findOne()` to get Mongoose document for `markModified()`)
4. Split key by `.` to get parts array
5. Initialize nested structure if needed:
   ```javascript
   if (!user.settings) user.settings = {};
   if (!user.settings[parts[0]]) user.settings[parts[0]] = {};
   if (!user.settings[parts[0]][parts[1]])
     user.settings[parts[0]][parts[1]] = {};
   ```
6. Set value: `user.settings[parts[0]][parts[1]][parts[2]] = value`
7. Call `user.markModified('settings')` (required for nested object updates)
8. Increment revision: `user.rev = (user.rev || 0) + 1`
9. Update timestamp: `user.updated_at = new Date()`
10. Save document: `await user.save()`
11. Remove password from response and return

**setSettings Logic**:

1. Validate that either `id` or `email` is provided, and `settings` is an object
2. Build query: `{ id: id }` or `{ email: email }`
3. Find user document
4. Replace entire settings object: `user.settings = settings`
5. Call `user.markModified('settings')`
6. Increment revision and update timestamp
7. Save document
8. Remove password from response and return

#### Controller Function Implementation

**settings.get Logic**:

1. Validate input using Joi:
   ```javascript
   const data = utility.validate(
     joi.object({
       key: joi.string().required(),
     }),
     req,
     res
   );
   ```
2. Call model function: `await user.settings.get({ id: req.user, key: data.key })`
3. Return response: `res.status(200).send({ data: result })`

**settings.set Logic**:

1. Validate input using Joi:
   ```javascript
   const data = utility.validate(
     joi.object({
       key: joi.string().required(),
       value: joi.any().required(),
     }),
     req,
     res
   );
   ```
2. Call model function: `await user.settings.set({ id: req.user, key: data.key, value: data.value })`
3. Return response: `res.status(200).send({ message: res.__('user.settings.updated'), data: result })`

**settings.setAll Logic**:

1. Validate input using Joi:
   ```javascript
   const data = utility.validate(
     joi.object({
       settings: joi.object().required(),
     }),
     req,
     res
   );
   ```
2. Call model function: `await user.settings.setAll({ id: req.user, settings: data.settings })`
3. Return response: `res.status(200).send({ message: res.__('user.settings.updated_all'), data: result })`

### Error Handling

**Model Layer**:

- Return `null` for `getSetting` if user not found or setting doesn't exist (non-error case)
- Throw error object `{ message: '...' }` if required parameters missing
- Let Mongoose validation errors propagate (handled by `use()` wrapper)

**Controller Layer**:

- Use `utility.validate()` for input validation (throws with proper format)
- Use `utility.assert()` for business logic validation
- All errors caught by `use()` HOF wrapper and handled by global error handler

### Security Considerations

1. **Authentication**: All routes require authentication (`auth.verify('user', ...)`)
2. **Authorization**: Users can only access/modify their own settings (enforced via `req.user`)
3. **Input Validation**: All inputs validated with Joi schemas
4. **Mass Assignment Prevention**: Only expected fields extracted via destructuring
5. **XSS Prevention**: Settings values stored as-is (no HTML escaping needed for JSON storage)
6. **Account Scoping**: Settings are user-scoped, not account-scoped (user preferences are global)

### Testing Strategy

#### Unit Tests

**Location**: `server/test/user.settings.test.js` (new file)

**Test Cases**:

1. **Model Tests - settings.get**:

   - âœ… Get setting with valid 3-level key
   - âœ… Get setting with 2-level key (returns feature object)
   - âœ… Get setting with 1-level key (returns subsystem object)
   - âœ… Get setting that doesn't exist (returns null)
   - âœ… Get setting for user that doesn't exist (returns null)
   - âœ… Get setting with email lookup
   - âœ… Get setting with id lookup

2. **Model Tests - settings.set**:

   - âœ… Set setting with valid 3-level key
   - âœ… Set setting creates nested structure if missing
   - âœ… Set setting updates existing value
   - âœ… Set setting with email lookup
   - âœ… Set setting with id lookup
   - âœ… Set setting increments revision
   - âœ… Set setting updates timestamp
   - âœ… Set setting throws error if user not found

3. **Model Tests - settings.setAll**:

   - âœ… Replace all settings with new object
   - âœ… Replace all settings preserves other user fields
   - âœ… Replace all settings increments revision
   - âœ… Replace all settings updates timestamp

4. **Controller Tests - settings.get**:

   - âœ… GET /api/user/settings?key=... returns setting value
   - âœ… GET /api/user/settings?key=... returns 404 if setting not found
   - âœ… GET /api/user/settings returns 400 if key missing
   - âœ… GET /api/user/settings requires authentication

5. **Controller Tests - settings.set**:

   - âœ… PUT /api/user/settings updates setting
   - âœ… PUT /api/user/settings returns 400 if key missing
   - âœ… PUT /api/user/settings returns 400 if value missing
   - âœ… PUT /api/user/settings requires authentication

6. **Controller Tests - settings.setAll**:
   - âœ… PUT /api/user/settings/all replaces all settings
   - âœ… PUT /api/user/settings/all returns 400 if settings missing
   - âœ… PUT /api/user/settings/all requires authentication

#### Integration Tests

**Location**: `server/test/user.test.js` (extend existing file)

**Test Cases**:

- âœ… Create user with default settings initialized
- âœ… Settings persist across user updates
- âœ… Settings work with user.get() response
- âœ… Settings don't interfere with other user operations

### Migration Considerations

**Existing Users**:

- Users without `settings` field will have it initialized as `{}` on first access
- No migration script needed - handled lazily in model functions
- `required: false` in schema allows existing users to continue working

**Backward Compatibility**:

- Settings system is additive - doesn't break existing functionality
- Default empty object prevents null reference errors
- All existing user operations continue to work unchanged

### Files to Modify

1. **`server/model/mongo/user.mongo.js`**:

   - Add `settings` field to schema
   - Update `create()` to initialize default settings
   - Add `exports.settings = {}` and three functions

2. **`server/controller/user.controller.js`**:

   - Add `exports.settings = {}` and three controller functions

3. **`server/api/user.route.js`**:

   - Add three route definitions

4. **`server/config/default.json`**:

   - Add `settings.default` configuration

5. **`server/api/spec.yaml`**:

   - Add `settings` property to User schema
   - Add three new endpoint definitions

6. **`server/test/user.settings.test.js`** (new file):

   - Create comprehensive test suite

7. **`server/test/user.test.js`**:
   - Add integration tests for settings

### Locale Strings

**Location**: `server/locales/user.en.json` (and other locales)

**Add**:

```json
{
  "settings": {
    "updated": "Setting updated successfully",
    "updated_all": "Settings updated successfully",
    "not_found": "Setting not found",
    "invalid_key": "Invalid settings key format"
  }
}
```

### Confidence Assessment

**Current Confidence Level**: 95%

**Rationale**:

- âœ… Clear understanding of existing codebase patterns
- âœ… Detailed implementation plan for all layers
- âœ… Security considerations addressed
- âœ… Error handling strategy defined
- âœ… Test strategy comprehensive
- âœ… Migration path clear
- âœ… Follows AI-RULES.md guidelines
- âœ… Consistent with existing code style

**Remaining Questions** (5% uncertainty):

1. Should settings be account-scoped or user-scoped? **Decision**: User-scoped (user preferences are global)
2. Should we validate settings structure? **Decision**: No validation - flexible structure for different apps
3. Should we add settings to user.get() response? **Decision**: Yes, include in response for convenience

### Next Steps

1. Review this design document
2. Address any questions or concerns
3. Once approved, proceed with implementation following this design
4. Create checkpoint tag before starting: `migration-checkpoint-before-settings`
5. Implement in order: Model â†’ Controller â†’ Routes â†’ Config â†’ Tests â†’ Spec â†’ Locales
6. Test thoroughly before creating phase tag: `migration-phase-6-settings`
